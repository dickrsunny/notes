
#### \_\_slots__的使用方法
- 默认情况下，Python 在各个实例中名为 \_\_dict__ 的字典里存储实例属性。如 3.9.3 节所述， 为了使用底层的散列表提升访问速度，字典会消耗大量内存。如果要处理数百万个属性不 多的实例，通过 \_\_slots__ 类属性，能节省大量内存，方法是让解释器在元组中存储实例 属性，而不用字典。
- 继承自超类的 \_\_slots__ 属性没有效果。Python 只会使用各个类中定义的 \_\_slots__ 属性。
- 定义 \_\_slots__ 的方式是，创建一个类属性，使用 \_\_slots__ 这个名字，并把它的值设为 一个字符串构成的可迭代对象，其中各个元素表示各个实例属性。例如：
    ~~~python
  class Vector2d:
    __slots__ = ('__x', '__y')
    ~~~
- 在类中定义 \_\_slots__ 属性的目的是告诉解释器:“这个类中的所有实例属性都在这儿 了!”这样，Python 会在各个实例中使用类似元组的结构存储实例变量，从而避免使用消 耗内存的 \_\_dict__ 属性。如果有数百万个实例同时活动，这样做能节省大量内存。
#### \_\_slots__的问题
- 总之，如果使用得当，\_\_slots__ 能显著节省内存，不过有几点要注意。
- 每个子类都要定义 \_\_slots__ 属性，因为解释器会忽略继承的 \_\_slots__ 属性。
- 实例只能拥有 \_\_slots__ 中列出的属性，除非把 '\_\_dict__' 加入 \_\_slots__ 中(这样做就失去了节省内存的功效)。
- 如果不把 '\_\_weakref__' 加入 \_\_slots__，实例就不能作为弱引用的目标。
- 如果你的程序不用处理数百万个实例，或许不值得费劲去创建不寻常的类，那就禁止它创 建动态属性或者不支持弱引用。与其他优化措施一样，仅当权衡当下的需求并仔细搜集资 料后证明确实有必要时，才应该使用 \_\_slots__ 属性。