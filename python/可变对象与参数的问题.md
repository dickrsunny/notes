- [不要使用可变类型作为参数的默认值](#%e4%b8%8d%e8%a6%81%e4%bd%bf%e7%94%a8%e5%8f%af%e5%8f%98%e7%b1%bb%e5%9e%8b%e4%bd%9c%e4%b8%ba%e5%8f%82%e6%95%b0%e7%9a%84%e9%bb%98%e8%ae%a4%e5%80%bc)
- [可变参数是否允许被改变](#%e5%8f%af%e5%8f%98%e5%8f%82%e6%95%b0%e6%98%af%e5%90%a6%e5%85%81%e8%ae%b8%e8%a2%ab%e6%94%b9%e5%8f%98)
- [传参和拷贝的区别](#%e4%bc%a0%e5%8f%82%e5%92%8c%e6%8b%b7%e8%b4%9d%e7%9a%84%e5%8c%ba%e5%88%ab)
#### 不要使用可变类型作为参数的默认值
- 可选参数可以有默认值，这是 Python 函数定义的一个很棒的特性，这样我们的 API 在进化的同时能保证向后兼容。然而，我们应该避免使用可变的对象作为参数的默认值。
- 因为默认值在定义函数时计算(通常在加载模块时, 只初始化一次)，因此默认值变成了函数对象的属性。因此，如果默认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。但是调用时传参（可变对象）就不会有问题。
#### 可变参数是否允许被改变
- 如果定义的函数接收可变参数，应该谨慎考虑调用方是否期望修改传入的参数。如果不允许改变的话，在传入后使用可变对象的拷贝代替。
#### 传参和拷贝的区别
- 传参
  - 无论是可变对象还是不可变对象，当作为参数时，传递的都是其引用的拷贝。当新的引用在函数中重新赋值后，它指向的新的对象，所以和原来的对象就不是同一个了。但可变对象的修改不影响新的引用，所以它指向的还是原来的对象。例如：
    - 不可变对象：
        ~~~python
        In [9]: c = 666

        In [10]: def t(d):
            ...:     print(c is d)
            ...:

        In [11]:

        In [11]: t(c)
        True
        ~~~
    - 可变对象：
        ~~~python
        In [36]: a = [999, 111]
        In [39]: def t2(b):
            ...:     b.append(222)
            ...:     print(a is b)
            ...:

        In [40]:
        In [40]: t2(a)
        True

- 浅拷贝
  - 对于可变对象来说，是创建了一个新的对象。但是新的对象中的引用是原来对象的引用的拷贝。例如：
      ~~~python
        In [1]: a = [3, [66, 55, 44], (7, 8, 9)]
        
        In [2]: b = list(a)
        
        In [3]: a is b
        Out[3]: False
        
        In [4]: b
        Out[4]: [3, [66, 55, 44], (7, 8, 9)]
        
        In [5]: a[0] is b[0]
        Out[5]: True
        
        In [6]: a[1] is b[1]
        Out[6]: True
      ~~~

  - 对于不可变对象来说，新的对象就是原来的对象，只是做了引用的拷贝。例如：
    ~~~python
        In [33]: q
        Out[33]: (8888, 9999)

        In [34]: w = tuple(q)

        In [35]: q is w
        Out[35]: True
    ~~~ 
- 深拷贝
  - 对于可变对象来说，是创建了一个新的对象。但是新的对象中的不可变对象的引用是原来对象中的不可变对象的引用的拷贝，而可变对象却是新的对象。例如：
      ~~~python
        In [41]: a = [111, [333, 999], 777777]
      
        In [42]: from copy import deepcopy
      
        In [43]: b = deepcopy(a)
      
        In [44]: b
        Out[44]: [111, [333, 999], 777777]
      
        In [45]: b is a
        Out[45]: False
      
        In [46]: b[0] is a[0]
        Out[46]: True
      
        In [47]: b[1] is a[1]
        Out[47]: False
      
        In [48]: b[2] is a[2]
        Out[48]: True
      ~~~
  - 对于不可变对象来说，新的对象就是原来的对象，只是做了引用的拷贝。例如：
    ~~~python
      In [51]: c = tuple([88888, 2222])

      In [52]: c
      Out[52]: (88888, 2222)
      
      In [53]: d = deepcopy(c)
      
      In [54]: d is c
      Out[54]: True
    ~~~