- [`mysql`逻辑架构](#mysql%e9%80%bb%e8%be%91%e6%9e%b6%e6%9e%84)
- [查找语句执行过程](#%e6%9f%a5%e6%89%be%e8%af%ad%e5%8f%a5%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b)
- [更新语句执行过程](#%e6%9b%b4%e6%96%b0%e8%af%ad%e5%8f%a5%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b)
#### `mysql`逻辑架构
![mysql逻辑架构图](./images/mysql逻辑架构图.png)
* `mysql`分为`server`层和存储引擎层
  * `server`层又主要分为：
    * 连接器：管理链接，权限验证；
    * 分析器：词法分析，语法分析；
    * 优化器：执行计划生成，索引选择；
    * 执行器：操作引擎，返回结果。
    * 查询缓存
  * 存储引擎层：负责数据的存取和提取。架构是插件式的，支持`InnoDB`、`MyISAM` 、`Memory`等多个存储引擎。
#### 查找语句执行过程
* ~~~sql
  select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
  ~~~
  * 既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。
  * 也可以先从表 t2 里面取出 d=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。(在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（`join`）的时候，决定各个表的连接顺序)
#### 更新语句执行过程
* ~~~sql
  update T set c=c+1 where ID=2;
  ~~~
  * 查询语句的那一套流程，更新语句同样会走一遍。在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。
  * 与查询流程不一样的是，更新流程还涉及两个重要的日志模块，redo log（重做日志）和 binlog（归档日志。
    * redo log & binlog
      * redo log 是 InnoDB 引擎特有的；binlog 是`mysql`的`server`层实现的，所有引擎都可以使用;
      * redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”;
      * redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。<br>
    
      有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程:
        * 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回;
        * 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务;
        * 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。<br>
      将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。<br>
    
      为什么日志需要“两阶段提交”?
        * 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。
        * 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。<br>
      可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用 binlog 来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。<br>
      简单说，redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。<br>
      注意：如果redo log prepare成功，binlog写失败，就算redo log commit失败也算成功。
      