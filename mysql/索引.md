- [索引的实现方式](#%e7%b4%a2%e5%bc%95%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f)
- [InnoDB索引模型](#innodb%e7%b4%a2%e5%bc%95%e6%a8%a1%e5%9e%8b)
- [基于主键索引和普通索引的区别](#%e5%9f%ba%e4%ba%8e%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95%e5%92%8c%e6%99%ae%e9%80%9a%e7%b4%a2%e5%bc%95%e7%9a%84%e5%8c%ba%e5%88%ab)
- [是否应该使用自增ID作为主键](#%e6%98%af%e5%90%a6%e5%ba%94%e8%af%a5%e4%bd%bf%e7%94%a8%e8%87%aa%e5%a2%9eid%e4%bd%9c%e4%b8%ba%e4%b8%bb%e9%94%ae)
- [覆盖索引](#%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95)
- [最左前缀原则](#%e6%9c%80%e5%b7%a6%e5%89%8d%e7%bc%80%e5%8e%9f%e5%88%99)
- [索引下推](#%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8)
- [注意事项](#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9)
#### 索引的实现方式
* 哈希表：适用于只有等值查询的场景；
* 有序数组：在等值查询和范围查询场景中的性能就都非常优秀，但只适用于静态存储引擎，增加、删除记录太高。
* 搜索树：都适用。
#### InnoDB索引模型
* 在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用 B+ 树索引模型，所以数据都是存储在 B+ 树中的。
#### 基于主键索引和普通索引的区别
* 如果语句是 
  ~~~sql
  select * from T where ID=500;
  ~~~
  即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
* 如果语句是 
  ~~~sql
  select * from T where k=5;
  ~~~
  即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。
* 也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。
#### 是否应该使用自增ID作为主键
* 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
* 而业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。
* 除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？<br>
  由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。<br>
  显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。
* 有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：只有一个索引；该索引必须是唯一索引。你一定看出来了，这就是典型的 KV 场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。
#### 覆盖索引
* 如果执行的语句是
  ~~~sql
  select ID from T where k between 3 and 5;
  ~~~
  这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。
* 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。
#### 最左前缀原则
* B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。
* 不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。
#### 索引下推
* 在 MySQL 5.6 之前，只能从联合索引命中的第一条记录的主键开始一个个回表。到主键索引上找出数据行，再对比字段值。
* 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
#### 注意事项
* drop主键索引会导致其他索引失效，但drop普通索引不会。